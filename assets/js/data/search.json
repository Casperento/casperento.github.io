[ { "title": "How to build the LLVM Test Suite with an arbitrary pass?", "url": "/posts/how-to-build-llvm-test-suite-with-an-arbitrary-pass/", "categories": "Compilers", "tags": "compilers, open-source", "date": "2024-05-15 21:00:00 -0300", "snippet": "Recently, I embarked on my journey in compiler design by joining UFMG’s Compilers Lab as a graduate researcher.My first challenge was to become familiar with LLVM and learn how to develop a pass fo...", "content": "Recently, I embarked on my journey in compiler design by joining UFMG’s Compilers Lab as a graduate researcher.My first challenge was to become familiar with LLVM and learn how to develop a pass for it. However, that’s not all, as we are also working with code compression techniques and require an infrastructure to test our developed passes. Fortunately, the LLVM Test Suite is available to us.We are using LLVM 17 and its test suite. However, we discovered that compiling the entire project with a newly created pass is not a trivial task, since there are no intermediate steps in the CMake project for us to specify our new pass in the compilation pipeline. Therefore, we began researching new ways to compile the entire project with our new pass.IntroductionPerhaps one of the nicest parts of the LLVM project is the Test Suite. This is a large collection of C and C++ benchmarks that compiler engineers can use to test the techniques that they implement. The suite includes a diverse array of programs and libraries, ranging from small, single-file programs to large, complex applications, ensuring comprehensive coverage of real-world scenarios.By leveraging this extensive test suite, developers can assess the performance, correctness, and robustness of their compiler optimizations and transformations. Furthermore, the suite is continually updated and maintained by the LLVM community, incorporating new benchmarks and reflecting the latest industry practices. This makes it an invaluable resource for anyone involved in compiler development or research, providing a solid foundation for testing and validating new ideas in compiler technology.Problem StatementOur task is to compile the entire Test Suite with an arbitrary pass, so that we can compare different metrics between a baseline and a chosen experiment. In other words, we want to enable the following pipeline: Compile every program in the Test Suite, producing a set of LLVM IRfiles. Let this collection of bytecodes be called “Control”; Collect metrics from “Control”; Compile every program in the Test Suite, this time with a set ofpasses of interest, producing a set of LLVM IR files. Let this newcollection of bytecodes be called “Test”; Collect metrics from “Test”; Produce a report comparing metrics from “Control” and “Test”.As an example, assume that we want to test the func-mergingpass. This pass takes functions that are structurally equal and mergethem to reduce code size. Imagine that we want to measure thecode-size reduction enabled by this optimization. LLVM provides a passto count instructions: instcount. Thus, we can combine these twopasses to get the numbers that we want, e.g.: Produce the “Control” set of bytecode files; Use the instcount pass to count the number of instructions in the“Control” dataset; Produce the “Test” dataset applying func-merging onto the Control dataset; Use the instcount pass to count the number of instructions in the“Test” dataset; Produce a report comparing the number of instructions in the“Control” and “Test” datasets.SolutionTo solve our problem, we’re going to: Apply a patch in the Test Suite’s CMake project; Run some shell commands to get the project compiled; Run the test suite with LIT to get the results; Finally, get the results compared.Cloning LLVM Test SuiteTo clone the project’s repository, run the following command inside a folder of your choice:$ git clone -b release/17.x https://github.com/llvm/llvm-test-suite.gitBuilding Test Suite BinariesTo build the project, we need to apply our patch into the CMake files. Then, we’ll configure and build the entire Test Suite with our patch.Applying the PatchThe following commit synthesizes all changes we’ve made in our patch, for you to apply it locally:Patch’s commitConfiguring and Building CMake ProjectIn our case, we want to count how many instructions programs have before applying our pass. Thus, we’re going to build the project two times, one to get the baseline tests’ results, and the second one to get our experiment tests’ result.First RunningAssuming your current directory is “path/to/llvm-test-suite”, run:$ mkdir -p build$ cd build$ cmake -G \"Ninja\" \\-DCMAKE_C_COMPILER=clang \\-DCMAKE_CXX_COMPILER=clang++ \\-DCMAKE_C_FLAGS=\"-flto\" \\-DCMAKE_CXX_FLAGS=\"-flto\" \\-DCMAKE_EXE_LINKER_FLAGS=\"-flto -fuse-ld=lld -Wl,--plugin-opt=-lto-embed-bitcode=post-merge-pre-opt\" \\-DTEST_SUITE_ARBITRARY_PASS=ON \\-DTEST_SUITE_SELECTED_PASSES= \\-DTEST_SUITE_PASSES_ARGS= \\\"-DTEST_SUITE_SUBDIRS=SingleSource;MultiSource\" \\-C ../cmake/caches/O1.cmake ..Note: we assume you already have ninja-build installed. If you don’t, just ignore the -G \"Ninja\" argument in the CMake command.Now, build the project with:$ cmake --build .Running LITTo run the tests with LIT, create a separate folder for the results and run it:$ mkdir -p ~/lit-results$ llvm-lit -v -o ~/lit-results/results_baseline.json .Second RunningThe chosen pass’ name must be specified by the TEST_SUITE_SELECTED_PASSES CMake env. variable. If you need to run a sequence of passes, just write them in the desired order separated by a comma, like: -DTEST_SUITE_SELECTED_PASSES=pass-1,pass-2It is also possible to pass arguments related to your pass using the following CMake env. variable: -DTEST_SUITE_PASSES_ARGS=-brfusion-soa=false\\;-brfusion-threshold=0Note: each option must be separated by the escaped semicolon character \\;.Then, to compile the test suite again with the chosen pass, reconfigure the CMake project with the following command:$ cmake -G \"Ninja\" \\-DCMAKE_C_COMPILER=clang \\-DCMAKE_CXX_COMPILER=clang++ \\-DCMAKE_C_FLAGS=\"-flto\" \\-DCMAKE_CXX_FLAGS=\"-flto\" \\-DCMAKE_EXE_LINKER_FLAGS=\"-flto -fuse-ld=lld -Wl,--plugin-opt=-lto-embed-bitcode=post-merge-pre-opt\" \\-DTEST_SUITE_ARBITRARY_PASS=ON \\-DTEST_SUITE_SELECTED_PASSES=func-merging \\-DTEST_SUITE_PASSES_ARGS= \\\"-DTEST_SUITE_SUBDIRS=SingleSource;MultiSource\" \\-C ../cmake/caches/O1.cmake ..Then, build the project again:$ cmake --build .Running LITRun the tests with LIT again:$ llvm-lit -v -o ~/lit-results/results_func-merging.json .Comparing ResultsTo compare the results by instcount and size..text metrics, run the following python script provided by the test suite:Assuming your current directory is “path/to/llvm-test-suite/build”.$ python3 ../utils/compare.py --full --diff -m instcount -m size..text ~/lit-results/results_baseline.json ~/lit-results/results_func-merging.json &gt; ~/lit-results/test-results.txtComparison ResultConclusionOur objective is to compile the Test Suite using different LLVM passes for metric comparison. Initially, we compile the suite with the instcount pass to determine the instruction count of generated bytecode files, establishing a baseline metric. Subsequently, we compile the same suite with the func-merging pass applied to the binaries and then reevaluate the instruction count.By analyzing the differences in instruction counts between the baseline (using instcount) and the experimental setup (with func-merging), we can draw conclusions on the effectiveness of the func-merging pass for code compression within the LLVM framework.ExtraThere are some tweaks we can do when configuring the CMake project. For instance, we can select specific test suites to be compiled and run by LIT. Moreover, it is possible to skip targets that failed the CMake build process. Finally, it is possible to configure a shell script to automate the process of running and comparing experiments.Build Specific Test SuitesLet’s say we want to compile only the SingleSource and MultiSource test suites. To do that, we need to specify them using the following CMake variable: -DTEST_SUITE_SUBDIRS=semicolon;separatedThis way, we get the following CMake command to configure our baseline build:$ cmake -G \"Ninja\" \\-DCMAKE_C_COMPILER=clang \\-DCMAKE_CXX_COMPILER=clang++ \\-DCMAKE_C_FLAGS=\"-flto\" \\-DCMAKE_CXX_FLAGS=\"-flto\" \\-DCMAKE_EXE_LINKER_FLAGS=\"-flto -fuse-ld=lld -Wl,--plugin-opt=-lto-embed-bitcode=post-merge-pre-opt\" \\-DTEST_SUITE_ARBITRARY_PASS=ON \\-DTEST_SUITE_SELECTED_PASSES= \\-DTEST_SUITE_PASSES_ARGS= \\\"-DTEST_SUITE_SUBDIRS=SingleSource;MultiSource\" \\-C ../cmake/caches/O1.cmake ..How to Skip Failed TargetsWhen building the CMake project, there may have some build targets that fail the compilation process at some step. Skipping these targets in the build process is interesting when you want to know what is the maximum number of targets you can build with your pass.To do that, first you need to know which build system you’re using. When using ninja-build, you can specify the -k option to skip all failed tests [4]. Once you know the correct CLI options that enables you to keep building the CMake project, you can append them into the build command using the -- chars:$ cmake --build . -- -k 0Running and Comparing Experiments AutomaticallyI had three passes to test and collect code size metrics. These are func-merging, loop-rolling and brfusion. Basically, if I want to collect those metrics, I just rebuild the test suite over and over. But there may have some build targets that failed, tests that don’t pass when they are compiled with different passes or tests that don’t terminate under LIT.To tackle these problems, my current approach is to ignore all files that are associated with failed tests and run the experiments in a chosen order.Building the test suite with my passes before the baseline guarantees that my comparison of results are computed correctly, given the same set of .test files.To prevent LIT from entering an infinite loop, I’ve used the --timeout CLI option to set a maximum time of execution of 120 seconds.$ llvm-lit -s --timeout 120 -v -o ~/lit-results/results_baseline.json .Note: to use this feature, you need to install the psutil python package.Here is the PoC of my approach: https://is.gd/Ezd8nv.ErrataIt was assumed in the CMake commands that the tests should not be really run by LIT, but instead they were being used to collect only code size metrics, compromising the correctness of each test. Hence, to fix that, I’ve removed the following CMake variable from the commands: -DTEST_SUITE_RUN_BENCHMARKS=OFFReferences[1] https://discourse.llvm.org/t/how-to-use-llvm-test-suite-to-experiment-with-alias-analysis/69668/10[2] https://releases.llvm.org/17.0.1/docs/TestSuiteGuide.html[3] https://releases.llvm.org/17.0.1/docs/CommandGuide/lit.html[4] https://manpages.debian.org/bullseye/ninja-build/ninja.1.en.html" }, { "title": "What's behind the so called 'code prettifier' tools?", "url": "/posts/what-s-behind-the-so-called-code-prettifier-tools/", "categories": "Compilers", "tags": "compilers, open-source", "date": "2023-02-22 21:00:00 -0300", "snippet": "If you’ve ever wondered the same question as the title, the short answer is: a compiler.Note: I have limited knowledge on code prettifier tools and their implementations.Now, let’s proceed with a b...", "content": "If you’ve ever wondered the same question as the title, the short answer is: a compiler.Note: I have limited knowledge on code prettifier tools and their implementations.Now, let’s proceed with a brief introduction on compilers and how I used my knowledge to solve a daily problem. This article is intended to be a technical report about a short implementation I’ve made for an open-source project called SQFvm, more on that later.What is a compiler ?A compiler is a program that takes a source code as input and translate it into a target code as output (figure 1).Figure 1: a compiler.Traditionally, the source code is written in a source language and the target code in a target language [1].The typical approach to designing a compiler is to divide it into a frontend and a backend. The former parses (analyze) the input text to generate code in an intermediate representation to pass it to the latter. Figure 2 shows the phases of a compiler.Figure 2: phases of a compiler (frontend and backend).Let’s focus on the frontend.The first step is to provide the source code to a compiler, after which the lexical analyzer starts to recognize groups of characters called tokens. These tokens are then passed to the syntax analyzer, which tries to derive the entire program as a long word by following the rules of a grammar and constructing an abstract syntax tree (AST or syntax tree, for short). The next phase is to traverse the AST in a manner that allows us to verify if any semantic rules have been broken. Finally, an intermediate representation of the original code is generated.I won’t delve deeper into each theoretical concept involved in each phase of a compiler. For now, the most important thing to know is that if we traverse an AST and print out a string at each node, that string can represent the formatted code, instead of an intermediate representation.Given the following SQF code, we could build an AST for it, like figure 3 shows:if (100 &gt; 2) exitWith {hint \"Some string...\"};At this point, it doesn’t matter what the code is doing, just that it is syntactically and semantically correct.Each node in the AST represent either a non-terminal or a terminal of our fictitious grammar. When we derive to the left or to the right child node, we apply a grammar rule until we get into a terminal (leaf node).Figure 3: AST for the SQF code above.Note: this AST doesn’t follow the grammar rules implemented in the SQFvm project, it is just an illustrated example.So, if we want to print the code in a formatted form, we need to traverse the AST recursively and print the content of each node or some contextual character (as seen in the red text in Figure 4).Figure 4: example of AST with printable characters.Given the AST above, it is possible to print an output code like:if (100 &gt; 2) exitWith { hint \"Some string...\"};The output code (red text in figure 4) is printed in the following order: Print if and derive the left node (to get expression value); Print ( and derive the only node child; Print left node value 100, then the current node character &lt;, finally print the right node value 2; Print ), after the recursive call that derived expression; Print exitWith and then derive the right node (to get block_of_code value); Print { and a newline character; Derive expressions, then print the unary_operator hint after four spaces characters, finally print the child string \"Some string...\"; Print };.From this example, we can see that we received a one-line code and translated it to a formatted version (with spaces and newline characters). However, it’s not a universal solution to format every possible script written in SQF. By the end of the day, we still need to handle some idiosyncrasies to print the output code correctly.What is SQFvm ?Originally created by X39, SQFvm is “a fully working and open-source Virtual Machine for the scripting language of the ArmA Games”, as stated in the project’s description.They already implemented a parser for the SQF language. So, the idea here is to use their AST to translate a non-formatted code into a formatted one.The following sections provide a detailed description of the Problem Statement, followed by examples of Input and Output. Finally, the Solution is explained along with the function that I’ve implemented in the SQFvm project.Problem StatementGiven a source code written in SQF language, format it into a more ‘readable’ form. The output code must stay ‘parseable’ by SQF parser.InputLet’s assume that the worst case scenario is a one-line source code.private _addons=[\"accessorys\",\"ai\",\"arrays\",\"common\",\"diagnostic\",\"disposable\",\"ee\",\"events\",\"hashes\",\"help\",\"jam\",\"jr\",\"keybinding\",\"main\",\"main_a3\",\"modules\",\"music\",\"network\",\"optics\",\"settings\",\"statemachine\",\"strings\",\"ui\",\"vectors\",\"versioning\",\"xeh\"];private _tests=[\"arrays\",\"common\",\"diagnostic\",\"events\",\"hashes\",\"network\",\"strings\",\"vectors\"];private _functions=[];{private _addons=_x;private _addonPath=format[\"\\x\\cba\\addons\\%1\",_x];private _addonSqfFiles=allFiles__[\".sqf\"];{private _addonFunctionPrefix=format[\"%1/fnc_\",_addons];if(_x find _addonFunctionPrefix&gt;0)then{private _splitStr=_x splitString \"/\";private _filename=_splitStr select(count _splitStr-1);private _filePath=format[\"%1\\%2\",_addonPath,_filename];if(not(_filePath in _functions))then{private _functionName=\"CBA_fnc_\"+(_filename select[4,count _filename-8]);missionNamespace setVariable[_functionName,compile preprocessFileLineNumbers _filePath];_functions pushBackUnique _filePath;};};}forEach _addonSqfFiles;}forEach _addons;{call compile preprocessFileLineNumbers format[\"\\x\\cba\\addons\\%1\\test.sqf\",_x];}forEach _tests;if(1&gt;2)exitWith{};nil;OutputA code formatted in a more ‘readable’ form.private _addons = [\"accessorys\", \"ai\", \"arrays\", \"common\", \"diagnostic\", \"disposable\", \"ee\", \"events\", \"hashes\", \"help\", \"jam\", \"jr\", \"keybinding\", \"main\", \"main_a3\", \"modules\", \"music\", \"network\", \"optics\", \"settings\", \"statemachine\", \"strings\", \"ui\", \"vectors\", \"versioning\", \"xeh\"];private _tests = [\"arrays\", \"common\", \"diagnostic\", \"events\", \"hashes\", \"network\", \"strings\", \"vectors\"];private _functions = [];{ private _addons = _x; private _addonPath = format [\"\\x\\cba\\addons\\%1\", _x]; private _addonSqfFiles = allfiles__ [\".sqf\"]; { private _addonFunctionPrefix = format [\"%1/fnc_\", _addons]; if (_x find _addonFunctionPrefix &gt; 0) then { private _splitStr = _x splitstring \"/\"; private _filename = _splitStr select count _splitStr - 1; private _filePath = format [\"%1\\%2\", _addonPath, _filename]; if (not _filePath in _functions) then { private _functionName = \"CBA_fnc_\" + _filename select [4, count _filename - 8]; missionNamespace setvariable [_functionName, compile preprocessfilelinenumbers _filePath]; _functions pushbackunique _filePath; }; }; } foreach _addonSqfFiles;} foreach _addons;{ call compile preprocessfilelinenumbers format [\"\\x\\cba\\addons\\%1\\test.sqf\", _x];} foreach _tests;if (1 &gt; 2) exitwith {};nil;SolutionTraverse the AST recursively and print out the node’s token content in a way that makes the output code easier to read.Four space characters were inserted before every expression inside a block of code (which is denoted by curly braces {...}), recursively. The newline character is inserted at the end of every non-empty block of code or expression (delimited by ;). Array elements, operators, keywords, functions, and variables’ names are printed, separated by spaces. if statements got their logical expression enclosed by (...) or ! (…), depending on the case. Finally, all keywords were lowered cased in the first implementation.Function implemented:https://github.com/SQFvm/runtime/blob/master/src/parser/sqf/sqf_formatter.cpp#L12References[1] Aho, A. V., Sethi, R., &amp; Ullman, J. D. (2007). Compilers: Principles, Techniques, and Tools (2nd ed.). Addison-Wesley Longman Publishing Co., Inc." }, { "title": "How to split strings using regex?", "url": "/posts/how-to-split-strings-using-regex/", "categories": "Pattern matching", "tags": "regex, python", "date": "2022-09-13 20:30:00 -0300", "snippet": "Problem StatementWhat if I ask you to split a paragraph in phrases delimited by .?! ?What would be your first approach ?Also, I want you to include the phrase itself and it’s delimiters (.?!) in th...", "content": "Problem StatementWhat if I ask you to split a paragraph in phrases delimited by .?! ?What would be your first approach ?Also, I want you to include the phrase itself and it’s delimiters (.?!) in the matches. So, you can’t simply call a split function like Python’s one, because you’re going to lose delimiters’ information, once you’ll get a list of strings that preceded one of the specified delimiters, and not the whole information (phrase + delimiters).For those of you who doesn’t know how to manipulate regex in Python, check it out their documentation. But keep reading this post to see how I use it to solve the problem.Next, is an example of input and output as well.Input(Example generated with $ lorem-ipsum-generator -s 50 -p 2 command, with small modifications to add all .?! delimiters)Laoreet. Etiam mi eu porta ac sit ve a mollis. Ad sollicitudin congue eu, sapien dolor adipiscing pretium nam. A, pellentesque cras, vivamus consequat lectus maecenas hymenaeos eros scelerisque. Urna at proin class a, ornare amet. Primis maecenas parturient cursus ultrices penatibus consectetuer vestibulum amet sapien aptent dis. Posuere eu, nisi natoque quis, ut duis mauris ad mi dis. Justo mi vitae proin vel enim id nisl quam parturient est.Rhoncus, massa ac hac hendrerit primis aenean, leo. Lorem. Platea. Risus.Luctus in, tortor quis et quam inceptos nulla quis et. Ante consectetuer ad ipsum in consequat felis tristique sed, felis. Magnis placerat hendrerit purus eu tempus ve! Ipsum in augue elit feugiat egestas erat lacus lacinia leo. Risus erat vivamus in, tortor at, ad augue aenean in. Vivamus nam adipiscing parturient et malesuada a lacus et porttitor velit. Tempor facilisis purus dictum cubilia dapibus libero. Porta ullamcorper ultrices dignissim ut semper. Felis tincidunt molestie duis penatibus montes maecenas ridiculus id, mauris ? Suspendisse nam. Adipiscing ad, erat eget in velit magnis dolor. Fusce consequat elementum eget nam cras integer iaculis consequat suscipit nulla vehicula nam etiam risus. Tristique parturient nec vestibulum parturient id mattis sociosqu ullamcorper maecenas, facilisis. Sed lacus conubia taciti. Erat ultrices mi, ipsum congue varius nam volutpat. Eu hymenaeos adipiscing, nec vitae tempus parturient curae duis sem mi. Vestibulum vel vestibulum tincidunt, porta ! Neque. Eros magnis ve dictumst.Output(List of matches)'Laoreet.'' Etiam mi eu porta ac sit ve a mollis.'' Ad sollicitudin congue eu, sapien dolor adipiscing pretium nam.'' A, pellentesque cras, vivamus consequat lectus maecenas hymenaeos eros scelerisque.'' Urna at proin class a, ornare amet.'' Primis maecenas parturient cursus ultrices penatibus consectetuer vestibulum amet sapien aptent dis.'' Posuere eu, nisi natoque quis, ut duis mauris ad mi dis.'' Justo mi vitae proin vel enim id nisl quam parturient est.''Rhoncus, massa ac hac hendrerit primis aenean, leo.'' Lorem.'' Platea.'' Risus.''Luctus in, tortor quis et quam inceptos nulla quis et.'' Ante consectetuer ad ipsum in consequat felis tristique sed, felis.'' Magnis placerat hendrerit purus eu tempus ve!'' Ipsum in augue elit feugiat egestas erat lacus lacinia leo.'' Risus erat vivamus in, tortor at, ad augue aenean in.'' Vivamus nam adipiscing parturient et malesuada a lacus et porttitor velit.'' Tempor facilisis purus dictum cubilia dapibus libero.'' Porta ullamcorper ultrices dignissim ut semper.'' Felis tincidunt molestie duis penatibus montes maecenas ridiculus id, mauris ?'' Suspendisse nam.'' Adipiscing ad, erat eget in velit magnis dolor.'' Fusce consequat elementum eget nam cras integer iaculis consequat suscipit nulla vehicula nam etiam risus.'' Tristique parturient nec vestibulum parturient id mattis sociosqu ullamcorper maecenas, facilisis.'' Sed lacus conubia taciti.'' Erat ultrices mi, ipsum congue varius nam volutpat.'' Eu hymenaeos adipiscing, nec vitae tempus parturient curae duis sem mi.'' Vestibulum vel vestibulum tincidunt, porta !'' Neque.'' Eros magnis ve dictumst.'SolutionFor solving this problem, I’m going to use Python’s re module to find all matches inside the input string. Also, I’m going to generate a file with dummy text to test my built pattern, using lorem-ipsum-generator. Generating dummy text:For the sake of simplicity I’m going to generate 2 paragraphs with a total of 50 sentences:$ lorem-ipsum-generator -s 50 -p 2 &gt; test.txt Building the pattern:First, I wanna match phrases that doesn’t end with any of the delimiters (.?!). So, I came up with the following pattern:[^.!?]+If this is correct, I’ll probably get something like:(The following output ignores ‘\\n’ matches)'Laoreet'' Etiam mi eu porta ac sit ve a mollis'' Ad sollicitudin congue eu, sapien dolor adipiscing pretium nam'' A, pellentesque cras, vivamus consequat lectus maecenas hymenaeos eros scelerisque'' Urna at proin class a, ornare amet'' Primis maecenas parturient cursus ultrices penatibus consectetuer vestibulum amet sapien aptent dis'' Posuere eu, nisi natoque quis, ut duis mauris ad mi dis'' Justo mi vitae proin vel enim id nisl quam parturient est''Rhoncus, massa ac hac hendrerit primis aenean, leo'' Lorem'' Platea'' Risus''Luctus in, tortor quis et quam inceptos nulla quis et'' Ante consectetuer ad ipsum in consequat felis tristique sed, felis'' Magnis placerat hendrerit purus eu tempus ve'' Ipsum in augue elit feugiat egestas erat lacus lacinia leo'' Risus erat vivamus in, tortor at, ad augue aenean in'' Vivamus nam adipiscing parturient et malesuada a lacus et porttitor velit'' Tempor facilisis purus dictum cubilia dapibus libero'' Porta ullamcorper ultrices dignissim ut semper'' Felis tincidunt molestie duis penatibus montes maecenas ridiculus id, mauris '' Suspendisse nam'' Adipiscing ad, erat eget in velit magnis dolor'' Fusce consequat elementum eget nam cras integer iaculis consequat suscipit nulla vehicula nam etiam risus'' Tristique parturient nec vestibulum parturient id mattis sociosqu ullamcorper maecenas, facilisis'' Sed lacus conubia taciti'' Erat ultrices mi, ipsum congue varius nam volutpat'' Eu hymenaeos adipiscing, nec vitae tempus parturient curae duis sem mi'' Vestibulum vel vestibulum tincidunt, porta '' Neque'' Eros magnis ve dictumst'Wait, but this is almost the same thing as running split method onto my input string. Note that I’ve lost delimiters’ information too…To fix this, I’m going to include delimiters in my pattern by adding the [.!?] sub-pattern into the end of my first one:[^.!?]+[.!?]Then, the output is:'Laoreet.'' Etiam mi eu porta ac sit ve a mollis.'' Ad sollicitudin congue eu, sapien dolor adipiscing pretium nam.'' A, pellentesque cras, vivamus consequat lectus maecenas hymenaeos eros scelerisque.'' Urna at proin class a, ornare amet.'' Primis maecenas parturient cursus ultrices penatibus consectetuer vestibulum amet sapien aptent dis.'' Posuere eu, nisi natoque quis, ut duis mauris ad mi dis.'' Justo mi vitae proin vel enim id nisl quam parturient est.''Rhoncus, massa ac hac hendrerit primis aenean, leo.'' Lorem.'' Platea.'' Risus.'andat lacus lacinia leo.'' Risus erat vivamus in, tortor at, ad augue aenean in.'' Vivamus nam adipiscing parturient et malesuada a lacus et porttitor velit.'' Tempor facilisis purus dictum cubilia dapibus libero.'' Porta ullamcorper ultrices dignissim ut semper.'' Felis tincidunt molestie duis penatibus montes maecenas ridiculus id, mauris ?'' Suspendisse nam.'' Adipiscing ad, erat eget in velit magnis dolor.'' Fusce consequat elementum eget nam cras integer iaculis consequat suscipit nulla vehicula nam etiam risus.'' Tristique parturient nec vestibulum parturient id mattis sociosqu ullamcorper maecenas, facilisis.'' Sed lacus conubia taciti.'' Erat ultrices mi, ipsum congue varius nam volutpat.'' Eu hymenaeos adipiscing, nec vitae tempus parturient curae duis sem mi.'' Vestibulum vel vestibulum tincidunt, porta !'' Neque.'' Eros magnis ve dictumst.'Python CodeGiven the final pattern, I search my input string (lines of test.txt file) for all matches using the re.findall(...) function.import re# Finding all pattern's matchesmatches = list()with open('test.txt', 'r') as f: for line in f: matches += list(re.findall(r'[^.!?]+[.!?]', line))# Printing listed matchesfor x in matches:\tprint(f'\\'{x}\\'')" }, { "title": "Downloading videos with multi-threaded youtube-dl", "url": "/posts/downloading-videos-with-multi-threaded-youtube-dl/", "categories": "Utils", "tags": "utils", "date": "2022-07-30 15:47:00 -0300", "snippet": "Today I’d like to share a trick I’ve learned to download videos faster using youtube-dl. The youtube-dl tool is a command-line utility to download videos from YouTube. But sometimes, when you try t...", "content": "Today I’d like to share a trick I’ve learned to download videos faster using youtube-dl. The youtube-dl tool is a command-line utility to download videos from YouTube. But sometimes, when you try to download a large video (something like &gt;=200MB of size), you might face a download time of 40 minutes or more, even when you’re used to download files of the same size faster. So, after researching some solution for this, I’ve found out that the best option is to use multiple threads to download the video content.First you need to have youtube-dl installed on your machine. Follow the official installation guide and you’re done.After that, you’re gonna need to download an external downloader to call from youtube-dl’s CLI. We’re gonna use aria2. Just grab a compiled version for your system, and add it to yout PATH variable.Finally, type the following command in your preferred shell to download a large video faster:$ youtube-dl --external-downloader aria2c --external-downloader-args \"-s 16 -x 16 -k 1M\" VIDEO-URLPassing these arguments to the external downloader aria2c, we’re gonna use 16 connections to download the video file (-s 16), in which each chunk of the file has 1MiB (-k 1M), limited by 16 connections with the server providing the file (-x 16).Finally, you can check aria2’s documentation to personalize arguments passed to it’s CLI." }, { "title": "Welcome to my blog!", "url": "/posts/Welcome-To-My-Blog!/", "categories": "About", "tags": "about", "date": "2022-06-19 23:00:00 -0300", "snippet": "Today i’m really excited to announce my new personal blog. As you can see, i’ve introduced myself on the About section of this blog. Hope you guys enjoy my content!", "content": "Today i’m really excited to announce my new personal blog. As you can see, i’ve introduced myself on the About section of this blog. Hope you guys enjoy my content!" } ]
